<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Unified HD Presenter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        :root { --toolbar-w: 80px; --accent: #3498db; }
        * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; color: white; font-family: sans-serif; height: 100vh; display: flex; overflow: hidden; }

        #viewport { flex-grow: 1; height: 100vh; display: flex; justify-content: center; align-items: center; padding: 10px; }
        #record-zone { 
            position: relative; width: 100%; max-width: 1200px; 
            aspect-ratio: 16 / 9; background: #fff; 
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
        }
        /* Unified Canvas for PDF + Drawing */
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; cursor: crosshair; }

        #toolbar-wrapper { width: var(--toolbar-w); height: 100vh; background: #151515; border-left: 1px solid #333; flex-shrink: 0; }
        #toolbar-scroll { height: 100%; overflow-y: auto; display: flex; flex-direction: column; align-items: center; padding: 20px 0; gap: 18px; touch-action: pan-y; }
        #toolbar-scroll::-webkit-scrollbar { width: 0px; }

        .tool-btn { background: #2a2a2a; border: 1px solid #444; color: #bbb; min-height: 52px; width: 52px; display: flex; align-items: center; justify-content: center; border-radius: 14px; cursor: pointer; font-size: 20px; flex-shrink: 0; }
        .tool-btn.active { background: var(--accent); color: white; }
        
        #page-num { font-size: 11px; font-weight: bold; color: #888; }
        .color-circle { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #444; cursor: pointer; flex-shrink: 0; }
        input[type="color"] { border: none; width: 40px; height: 40px; background: none; cursor: pointer; }
        input[type="range"] { width: 50px; cursor: pointer; }

        #upload-screen { position: fixed; inset: 0; background: #0b0b0b; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #rec-indicator { position: absolute; top: 20px; left: 20px; color: #ff4757; font-size: 14px; font-weight: bold; display: none; z-index: 100; }
        .label { font-size: 9px; color: #555; font-weight: bold; margin-bottom: -12px; }
    </style>
</head>
<body>

<div id="rec-indicator"><i class="fas fa-circle"></i> RECORDING...</div>

<div id="upload-screen">
    <i class="fas fa-file-pdf fa-5x" style="color:var(--accent); margin-bottom: 20px;"></i>
    <input type="file" id="file-input" accept=".pdf">
    <p>Upload PDF to start unified recording</p>
</div>

<div id="viewport">
    <div id="record-zone">
        <canvas id="main-canvas"></canvas>
    </div>
</div>

<div id="toolbar-wrapper">
    <div id="toolbar-scroll">
        <button class="tool-btn" onclick="navPage(-1)"><i class="fas fa-chevron-up"></i></button>
        <span id="page-num">0/0</span>
        <button class="tool-btn" onclick="navPage(1)"><i class="fas fa-chevron-down"></i></button>
        
        <hr width="40" style="opacity:0.1">
        
        <button class="tool-btn active" id="pen-btn" onclick="setTool('pen')"><i class="fas fa-pen-nib"></i></button>
        <button class="tool-btn" id="eraser-btn" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
        
        <div class="color-circle" style="background: #ff0000;" onclick="pickColor('#ff0000')"></div>
        <div class="color-circle" style="background: #00ff00;" onclick="pickColor('#00ff00')"></div>
        <div class="color-circle" style="background: #ffffff;" onclick="pickColor('#ffffff')"></div>
        <input type="color" id="color-picker" value="#ff0000" onchange="pickColor(this.value)">
        
        <input type="range" id="size-slider" min="1" max="60" value="6">
        
        <hr width="40" style="opacity:0.1">
        
        <button class="tool-btn" onclick="undo()"><i class="fas fa-undo"></i></button>
        <button class="tool-btn" onclick="clearDraw()"><i class="fas fa-trash-alt"></i></button>
        
        <div class="label">REC</div>
        <button class="tool-btn" id="rec-btn" onclick="toggleRecording()" style="color:#ff4757;"><i class="fas fa-microphone"></i></button>
        
        <div class="label">FS</div>
        <button class="tool-btn" id="fs-btn" onclick="toggleFullscreen()"><i class="fas fa-expand"></i></button>
    </div>
</div>

<script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    let pdfDoc = null, pageNum = 1, currentTool = 'pen', isDrawing = false;
    let historyStack = [], points = [];
    
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    // 1. PDF LOADING
    document.getElementById('file-input').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        document.getElementById('upload-screen').style.display = 'none';
        const buffer = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument({data: buffer}).promise;
        renderPage();
    };

    async function renderPage() {
        const page = await pdfDoc.getPage(pageNum);
        const container = document.getElementById('record-zone');
        const rect = container.getBoundingClientRect();
        
        const dpr = (window.devicePixelRatio || 1) * 2.5; 
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;

        const viewport = page.getViewport({ scale: canvas.width / page.getViewport({scale: 1}).width });
        
        // Render PDF directly to the main canvas
        await page.render({ canvasContext: ctx, viewport: viewport }).promise;
        document.getElementById('page-num').innerText = `${pageNum}/${pdfDoc.numPages}`;
        
        // Save this clean state as the base of history
        historyStack = [canvas.toDataURL()];
    }

    // 2. SMOOTH WRITING
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
        return {
            x: (clientX - rect.left) * (canvas.width / rect.width),
            y: (clientY - rect.top) * (canvas.height / rect.height)
        };
    }

    const startDraw = (e) => {
        isDrawing = true;
        points = [getPos(e)];
    };

    const drawMove = (e) => {
        if (!isDrawing) return;
        if (e.cancelable) e.preventDefault();
        const pos = getPos(e);
        points.push(pos);

        ctx.lineJoin = ctx.lineCap = 'round';
        ctx.strokeStyle = currentTool === 'eraser' ? '#ffffff' : document.getElementById('color-picker').value;
        ctx.lineWidth = document.getElementById('size-slider').value * (canvas.width / 1200); 

        if (points.length > 2) {
            ctx.beginPath();
            ctx.moveTo(points[points.length - 3].x, points[points.length - 3].y);
            const xc = (points[points.length - 2].x + points[points.length - 1].x) / 2;
            const yc = (points[points.length - 2].y + points[points.length - 1].y) / 2;
            ctx.quadraticCurveTo(points[points.length - 2].x, points[points.length - 2].y, xc, yc);
            ctx.stroke();
        }
    };

    const stopDraw = () => { 
        if(isDrawing) {
            isDrawing = false; 
            historyStack.push(canvas.toDataURL());
            if(historyStack.length > 30) historyStack.shift();
        }
        points = []; 
    };

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', drawMove);
    window.addEventListener('mouseup', stopDraw);
    canvas.addEventListener('touchstart', startDraw, {passive:false});
    canvas.addEventListener('touchmove', drawMove, {passive:false});
    canvas.addEventListener('touchend', stopDraw);

    function navPage(dir) {
        if (!pdfDoc || pageNum + dir < 1 || pageNum + dir > pdfDoc.numPages) return;
        pageNum += dir;
        renderPage();
    }

    function setTool(t) {
        currentTool = t;
        document.getElementById('pen-btn').classList.toggle('active', t === 'pen');
        document.getElementById('eraser-btn').classList.toggle('active', t === 'eraser');
    }

    function pickColor(color) {
        document.getElementById('color-picker').value = color;
        setTool('pen');
    }

    function undo() {
        if (historyStack.length > 1) {
            historyStack.pop(); // Remove current
            let img = new Image();
            img.src = historyStack[historyStack.length - 1];
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
        }
    }

    function clearDraw() { renderPage(); }

    function toggleFullscreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    }

    // 3. RECORDING (Unified Canvas)
    let recorder, chunks = [];
    async function toggleRecording() {
        const btn = document.getElementById('rec-btn');
        const indicator = document.getElementById('rec-indicator');

        if (recorder && recorder.state === 'recording') {
            recorder.stop();
            indicator.style.display = 'none';
            return;
        }

        try {
            const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            // Since everything is on ONE canvas, captureStream works perfectly
            const videoStream = canvas.captureStream(30);
            const combined = new MediaStream([...videoStream.getTracks(), ...audioStream.getTracks()]);

            recorder = new MediaRecorder(combined, { mimeType: 'video/webm;codecs=vp9' });
            chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `HD_Lecture_${Date.now()}.webm`;
                a.click();
                audioStream.getTracks().forEach(t => t.stop());
            };
            recorder.start();
            indicator.style.display = 'block';
        } catch (e) {
            alert("Recording Error: Ensure you have granted Microphone permissions.");
        }
    }
</script>
</body>
</html>
