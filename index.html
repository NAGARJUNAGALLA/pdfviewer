<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HD Content Presenter Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        :root { --toolbar-w: 85px; --accent: #3498db; }
        * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; color: white; font-family: sans-serif; height: 100vh; display: flex; overflow: hidden; }

        /* Content Area */
        #viewport { flex-grow: 1; height: 100vh; display: flex; justify-content: center; align-items: center; padding: 10px; position: relative; }
        #record-zone { 
            position: relative; width: 100%; max-width: 1200px; 
            aspect-ratio: 16 / 9; background: #fff; 
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            overflow: hidden;
        }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #draw-layer { z-index: 50; cursor: crosshair; }
        #pdf-layer { z-index: 10; }
        #recorder-canvas { display: none; } /* Master canvas for recording content only */

        /* Scrollable Sidebar */
        #toolbar-wrapper { width: var(--toolbar-w); height: 100vh; background: #151515; border-left: 1px solid #333; flex-shrink: 0; }
        #toolbar-scroll { 
            height: 100%; overflow-y: auto; display: flex; 
            flex-direction: column; align-items: center; padding: 20px 0; gap: 18px; 
            touch-action: pan-y;
        }
        #toolbar-scroll::-webkit-scrollbar { width: 0px; }

        .tool-btn {
            background: #2a2a2a; border: 1px solid #444; color: #bbb;
            min-height: 54px; width: 54px; display: flex; align-items: center;
            justify-content: center; border-radius: 14px; cursor: pointer; font-size: 20px;
            flex-shrink: 0; transition: all 0.2s;
        }
        .tool-btn.active { background: var(--accent); color: white; border-color: var(--accent); transform: scale(1.05); }
        
        #page-num { font-size: 12px; font-weight: bold; color: #888; }
        .color-circle { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #444; cursor: pointer; flex-shrink: 0; }
        input[type="color"] { border: none; width: 42px; height: 42px; background: none; cursor: pointer; }
        input[type="range"] { width: 60px; cursor: pointer; }

        #upload-screen {
            position: fixed; inset: 0; background: #0b0b0b; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #rec-indicator { position: absolute; top: 20px; left: 20px; color: #ff4757; font-size: 14px; font-weight: bold; display: none; z-index: 100; text-shadow: 0 0 10px rgba(255,0,0,0.5); }
        .label { font-size: 9px; color: #666; font-weight: bold; margin-bottom: -12px; text-transform: uppercase; }
    </style>
</head>
<body>

<div id="rec-indicator"><i class="fas fa-circle"></i> RECORDING...</div>

<div id="upload-screen">
    <i class="fas fa-file-pdf fa-5x" style="color:var(--accent); margin-bottom: 25px;"></i>
    <input type="file" id="file-input" accept=".pdf">
    <p style="color: #888;">Select PDF to start recording strictly content</p>
</div>

<div id="viewport">
    <div id="record-zone">
        <canvas id="pdf-layer"></canvas>
        <canvas id="draw-layer"></canvas>
        <canvas id="recorder-canvas"></canvas> 
    </div>
</div>

<div id="toolbar-wrapper">
    <div id="toolbar-scroll">
        <button class="tool-btn" onclick="navPage(-1)"><i class="fas fa-chevron-up"></i></button>
        <span id="page-num">0/0</span>
        <button class="tool-btn" onclick="navPage(1)"><i class="fas fa-chevron-down"></i></button>
        
        <hr width="40" style="opacity:0.1">
        
        <button class="tool-btn active" id="pen-btn" onclick="setTool('pen')"><i class="fas fa-pen-nib"></i></button>
        <button class="tool-btn" id="eraser-btn" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
        
        <div class="label">Color</div>
        <div class="color-circle" style="background: #ff0000;" onclick="pickColor('#ff0000')"></div>
        <div class="color-circle" style="background: #00ff00;" onclick="pickColor('#00ff00')"></div>
        <div class="color-circle" style="background: #ffffff;" onclick="pickColor('#ffffff')"></div>
        <input type="color" id="color-picker" value="#ff0000" onchange="pickColor(this.value)">
        
        <div class="label">Size</div>
        <input type="range" id="size-slider" min="1" max="60" value="6">
        
        <hr width="40" style="opacity:0.1">
        
        <button class="tool-btn" onclick="undo()"><i class="fas fa-undo"></i></button>
        <button class="tool-btn" onclick="clearDraw()"><i class="fas fa-trash-can"></i></button>
        
        <div class="label">REC</div>
        <button class="tool-btn" id="rec-btn" onclick="toggleRecording()" style="color:#ff4757;"><i class="fas fa-microphone"></i></button>
        
        <div class="label">FS</div>
        <button class="tool-btn" id="fs-btn" onclick="toggleFullscreen()"><i class="fas fa-expand"></i></button>
    </div>
</div>

<script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    let pdfDoc = null, pageNum = 1, currentTool = 'pen', isDrawing = false;
    let points = [], historyStack = [], needsUpdate = true;
    
    const drawCanvas = document.getElementById('draw-layer');
    const dCtx = drawCanvas.getContext('2d');
    const pdfCanvas = document.getElementById('pdf-layer');
    const pCtx = pdfCanvas.getContext('2d');
    const recCanvas = document.getElementById('recorder-canvas');
    const rCtx = recCanvas.getContext('2d');

    // 1. SETUP & PERFORMANCE LOOP
    document.getElementById('file-input').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        document.getElementById('upload-screen').style.display = 'none';
        const buffer = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument(buffer).promise;
        renderPage();
        requestAnimationFrame(updateRecorderLoop);
    };

    function updateRecorderLoop() {
        if (needsUpdate) {
            rCtx.fillStyle = "white";
            rCtx.fillRect(0, 0, recCanvas.width, recCanvas.height);
            rCtx.drawImage(pdfCanvas, 0, 0);
            rCtx.drawImage(drawCanvas, 0, 0);
            needsUpdate = false;
        }
        requestAnimationFrame(updateRecorderLoop);
    }

    async function renderPage() {
        const page = await pdfDoc.getPage(pageNum);
        const container = document.getElementById('record-zone');
        const rect = container.getBoundingClientRect();
        const dpr = (window.devicePixelRatio || 1) * 2.5; 
        
        pdfCanvas.width = drawCanvas.width = recCanvas.width = rect.width * dpr;
        pdfCanvas.height = drawCanvas.height = rect.height * dpr;

        const viewport = page.getViewport({ scale: pdfCanvas.width / page.getViewport({scale: 1}).width });
        await page.render({ canvasContext: pCtx, viewport: viewport }).promise;
        document.getElementById('page-num').innerText = `${pageNum}/${pdfDoc.numPages}`;
        
        clearDraw();
        needsUpdate = true;
    }

    // 2. PEN LOGIC
    function getPos(e) {
        const rect = drawCanvas.getBoundingClientRect();
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
        return {
            x: (clientX - rect.left) * (drawCanvas.width / rect.width),
            y: (clientY - rect.top) * (drawCanvas.height / rect.height)
        };
    }

    const startDraw = (e) => {
        isDrawing = true;
        points = [getPos(e)];
        saveHistory();
    };

    const drawMove = (e) => {
        if (!isDrawing) return;
        if (e.cancelable) e.preventDefault();
        const pos = getPos(e);
        points.push(pos);

        dCtx.lineJoin = dCtx.lineCap = 'round';
        dCtx.strokeStyle = currentTool === 'eraser' ? '#ffffff' : document.getElementById('color-picker').value;
        dCtx.lineWidth = document.getElementById('size-slider').value * (drawCanvas.width / 1200); 

        if (points.length > 2) {
            dCtx.beginPath();
            dCtx.moveTo(points[points.length - 3].x, points[points.length - 3].y);
            const xc = (points[points.length - 2].x + points[points.length - 1].x) / 2;
            const yc = (points[points.length - 2].y + points[points.length - 1].y) / 2;
            dCtx.quadraticCurveTo(points[points.length - 2].x, points[points.length - 2].y, xc, yc);
            dCtx.stroke();
            needsUpdate = true;
        }
    };

    const stopDraw = () => { isDrawing = false; points = []; };

    drawCanvas.addEventListener('mousedown', startDraw);
    drawCanvas.addEventListener('mousemove', drawMove);
    window.addEventListener('mouseup', stopDraw);
    drawCanvas.addEventListener('touchstart', startDraw, {passive:false});
    drawCanvas.addEventListener('touchmove', drawMove, {passive:false});
    drawCanvas.addEventListener('touchend', stopDraw);

    function navPage(dir) {
        if (!pdfDoc || pageNum + dir < 1 || pageNum + dir > pdfDoc.numPages) return;
        pageNum += dir;
        renderPage();
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }

    function pickColor(color) {
        document.getElementById('color-picker').value = color;
        setTool('pen');
    }

    function setTool(t) {
        currentTool = t;
        document.getElementById('pen-btn').classList.toggle('active', t === 'pen');
        document.getElementById('eraser-btn').classList.toggle('active', t === 'eraser');
    }

    function saveHistory() { historyStack.push(drawCanvas.toDataURL()); if(historyStack.length > 20) historyStack.shift(); }
    function undo() {
        if (historyStack.length > 0) {
            let img = new Image(); img.src = historyStack.pop();
            img.onload = () => { dCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height); dCtx.drawImage(img,0,0); needsUpdate = true; };
        }
    }
    function clearDraw() { dCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height); historyStack = []; needsUpdate = true; }

    // 3. UNIFIED CONTENT RECORDING
    let recorder, chunks = [];
    async function toggleRecording() {
        const btn = document.getElementById('rec-btn');
        const indicator = document.getElementById('rec-indicator');

        if (recorder && recorder.state === 'recording') {
            recorder.stop();
            btn.classList.remove('active');
            indicator.style.display = 'none';
            return;
        }

        try {
            const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const videoStream = recCanvas.captureStream(30); // Specifically capture ONLY the content canvas
            const combined = new MediaStream([...videoStream.getTracks(), ...audioStream.getTracks()]);

            recorder = new MediaRecorder(combined, { mimeType: 'video/webm;codecs=vp9' });
            chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `HD_Content_Recording_${Date.now()}.webm`;
                a.click();
                audioStream.getTracks().forEach(t => t.stop());
            };
            recorder.start();
            btn.classList.add('active');
            indicator.style.display = 'block';
        } catch (e) {
            alert("Recording Error: Ensure Microphone access is granted.");
        }
    }
</script>
</body>
</html>
