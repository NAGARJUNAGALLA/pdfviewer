<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HD Content Presenter Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
        :root { --toolbar-w: 75px; --accent: #3498db; }
        * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; color: white; font-family: sans-serif; height: 100vh; display: flex; overflow: hidden; }

        /* Content Area */
        #viewport { flex-grow: 1; height: 100vh; display: flex; justify-content: center; align-items: center; padding: 10px; position: relative; }
        
        #record-zone { 
            position: relative; width: 100%; max-width: 1200px; 
            aspect-ratio: 16 / 9; background: #fff; 
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
        }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #draw-layer { z-index: 50; cursor: crosshair; }
        #pdf-layer { z-index: 10; }
        #recorder-canvas { display: none; } 

        /* Scrollable Toolbar */
        #toolbar-wrapper { width: var(--toolbar-w); height: 100vh; background: #1a1a1a; border-left: 1px solid #333; flex-shrink: 0; }
        #toolbar-scroll { 
            height: 100%; overflow-y: auto; display: flex; 
            flex-direction: column; align-items: center; padding: 20px 0; gap: 20px; 
            touch-action: pan-y;
        }
        #toolbar-scroll::-webkit-scrollbar { width: 0px; }

        .tool-btn {
            background: #252525; border: 1px solid #444; color: #999;
            min-height: 52px; width: 52px; display: flex; align-items: center;
            justify-content: center; border-radius: 12px; cursor: pointer; font-size: 20px;
            flex-shrink: 0;
        }
        .tool-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
        
        #page-num { font-size: 12px; font-weight: bold; color: #777; }
        input[type="color"] { border: none; width: 40px; height: 40px; background: none; cursor: pointer; }
        input[type="range"] { width: 50px; cursor: pointer; }

        #upload-screen {
            position: fixed; inset: 0; background: #111; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #rec-indicator { position: absolute; top: 15px; left: 15px; color: #ff4757; font-size: 14px; font-weight: bold; display: none; z-index: 100; }
        .label { font-size: 9px; color: #555; font-weight: bold; margin-bottom: -15px; }
    </style>
</head>
<body>

<div id="rec-indicator"><i class="fas fa-circle"></i> REC</div>

<div id="upload-screen">
    <i class="fas fa-file-pdf fa-4x" style="color:var(--accent); margin-bottom: 20px;"></i>
    <input type="file" id="file-input" accept=".pdf">
    <p>Upload PDF to Start</p>
</div>

<div id="viewport">
    <div id="record-zone">
        <canvas id="pdf-layer"></canvas>
        <canvas id="draw-layer"></canvas>
        <canvas id="recorder-canvas"></canvas> 
    </div>
</div>

<div id="toolbar-wrapper">
    <div id="toolbar-scroll">
        <button class="tool-btn" onclick="navPage(-1)"><i class="fas fa-chevron-up"></i></button>
        <span id="page-num">0/0</span>
        <button class="tool-btn" onclick="navPage(1)"><i class="fas fa-chevron-down"></i></button>
        
        <hr width="30" style="opacity:0.1">
        
        <button class="tool-btn active" id="pen-btn" onclick="setTool('pen')"><i class="fas fa-pen-nib"></i></button>
        <button class="tool-btn" id="eraser-btn" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
        <input type="color" id="color-picker" value="#ff0000">
        <input type="range" id="size-slider" min="1" max="50" value="5">
        
        <hr width="30" style="opacity:0.1">
        
        <button class="tool-btn" onclick="undo()"><i class="fas fa-undo"></i></button>
        <button class="tool-btn" onclick="clearDraw()"><i class="fas fa-trash"></i></button>
        
        <div class="label">REC</div>
        <button class="tool-btn" id="rec-btn" onclick="toggleRecording()" style="color:#ff4757;"><i class="fas fa-video"></i></button>
        
        <div class="label">SCREEN</div>
        <button class="tool-btn" id="fs-btn" onclick="toggleFullscreen()"><i class="fas fa-expand"></i></button>
    </div>
</div>

<script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    let pdfDoc = null, pageNum = 1, currentTool = 'pen', isDrawing = false;
    let points = [], historyStack = [];
    
    const drawCanvas = document.getElementById('draw-layer');
    const dCtx = drawCanvas.getContext('2d');
    const pdfCanvas = document.getElementById('pdf-layer');
    const pCtx = pdfCanvas.getContext('2d');
    const recCanvas = document.getElementById('recorder-canvas');
    const rCtx = recCanvas.getContext('2d');

    // 1. FILE LOAD
    document.getElementById('file-input').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        toggleFullscreen(); // Enter FS on load
        document.getElementById('upload-screen').style.display = 'none';
        const buffer = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument(buffer).promise;
        renderPage();
    };

    // FULLSCREEN TOGGLE LOGIC
    function toggleFullscreen() {
        const btn = document.getElementById('fs-btn');
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {});
            btn.innerHTML = '<i class="fas fa-compress"></i>';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
                btn.innerHTML = '<i class="fas fa-expand"></i>';
            }
        }
    }

    // Monitor FS changes (e.g., if user hits ESC key)
    document.addEventListener('fullscreenchange', () => {
        const btn = document.getElementById('fs-btn');
        if (!document.fullscreenElement) {
            btn.innerHTML = '<i class="fas fa-expand"></i>';
        } else {
            btn.innerHTML = '<i class="fas fa-compress"></i>';
        }
    });

    async function renderPage() {
        const page = await pdfDoc.getPage(pageNum);
        const container = document.getElementById('record-zone');
        const rect = container.getBoundingClientRect();
        
        const dpr = (window.devicePixelRatio || 1) * 2.5; 
        pdfCanvas.width = drawCanvas.width = recCanvas.width = rect.width * dpr;
        pdfCanvas.height = drawCanvas.height = recCanvas.height * dpr;

        const viewport = page.getViewport({ scale: pdfCanvas.width / page.getViewport({scale:1}).width });
        await page.render({ canvasContext: pCtx, viewport }).promise;
        document.getElementById('page-num').innerText = `${pageNum}/${pdfDoc.numPages}`;
        clearDraw();
        updateRecorderCanvas();
    }

    // 2. SMOOTH WRITING
    function getPos(e) {
        const rect = drawCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: (clientX - rect.left) * (drawCanvas.width / rect.width),
            y: (clientY - rect.top) * (drawCanvas.height / rect.height)
        };
    }

    const startDraw = (e) => {
        isDrawing = true;
        points = [getPos(e)];
        saveHistory();
    };

    const drawMove = (e) => {
        if (!isDrawing) return;
        e.preventDefault();
        const pos = getPos(e);
        points.push(pos);

        dCtx.lineJoin = dCtx.lineCap = 'round';
        dCtx.strokeStyle = currentTool === 'eraser' ? '#ffffff' : document.getElementById('color-picker').value;
        dCtx.lineWidth = document.getElementById('size-slider').value * (drawCanvas.width / 1200); 

        if (points.length > 2) {
            dCtx.beginPath();
            dCtx.moveTo(points[points.length - 3].x, points[points.length - 3].y);
            const xc = (points[points.length - 2].x + points[points.length - 1].x) / 2;
            const yc = (points[points.length - 2].y + points[points.length - 1].y) / 2;
            dCtx.quadraticCurveTo(points[points.length - 2].x, points[points.length - 2].y, xc, yc);
            dCtx.stroke();
        }
        updateRecorderCanvas();
    };

    function updateRecorderCanvas() {
        rCtx.fillStyle = "white";
        rCtx.fillRect(0, 0, recCanvas.width, recCanvas.height);
        rCtx.drawImage(pdfCanvas, 0, 0);
        rCtx.drawImage(drawCanvas, 0, 0);
    }

    const stopDraw = () => { isDrawing = false; points = []; };

    drawCanvas.addEventListener('mousedown', startDraw);
    drawCanvas.addEventListener('mousemove', drawMove);
    window.addEventListener('mouseup', stopDraw);
    drawCanvas.addEventListener('touchstart', startDraw, {passive:false});
    drawCanvas.addEventListener('touchmove', drawMove, {passive:false});
    drawCanvas.addEventListener('touchend', stopDraw);

    function navPage(dir) {
        if (!pdfDoc || pageNum + dir < 1 || pageNum + dir > pdfDoc.numPages) return;
        pageNum += dir;
        renderPage();
    }

    function setTool(t) {
        currentTool = t;
        document.getElementById('pen-btn').classList.toggle('active', t === 'pen');
        document.getElementById('eraser-btn').classList.toggle('active', t === 'eraser');
    }

    function saveHistory() { historyStack.push(drawCanvas.toDataURL()); if(historyStack.length > 20) historyStack.shift(); }
    function undo() {
        if (historyStack.length > 0) {
            let img = new Image(); img.src = historyStack.pop();
            img.onload = () => { dCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height); dCtx.drawImage(img,0,0); updateRecorderCanvas(); };
        }
    }
    function clearDraw() { dCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height); historyStack = []; updateRecorderCanvas(); }

    // 3. CONTENT RECORDING
    let recorder, chunks = [];
    async function toggleRecording() {
        const btn = document.getElementById('rec-btn');
        const indicator = document.getElementById('rec-indicator');

        if (recorder && recorder.state === 'recording') {
            recorder.stop();
            indicator.style.display = 'none';
            return;
        }

        try {
            const audio = await navigator.mediaDevices.getUserMedia({ audio: true });
            const stream = recCanvas.captureStream(30);
            const combined = new MediaStream([...stream.getTracks(), ...audio.getTracks()]);

            recorder = new MediaRecorder(combined, { mimeType: 'video/webm' });
            chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'presentation_hd.webm';
                a.click();
                audio.getTracks().forEach(t => t.stop());
            };
            recorder.start();
            indicator.style.display = 'block';
        } catch (e) {
            alert("Recording requires Microphone access.");
        }
    }
</script>
</body>
</html>
